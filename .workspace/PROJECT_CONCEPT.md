# Project Concept: DCL Agent

**Version:** 1.0  
**Created:** 2025-12-06  
**Last Updated:** 2025-12-18

---

## Введение

Проект **DCL Agent** реализует «оркестратор» для исполнения инструкций на языке **Domain Context Language (DCL)**. DCL Agent является фундаментальным строительным блоком в слое **Agentic Runtime**, транслируя высокоуровневые бизнес-интенции (описанные на DCL) в серии вызовов LLM API с корректно собранным контекстом.

**Основная ценность:** Агент обеспечивает **декларативное управление контекстом** для LLM через DCL, отделяя бизнес-логику (что делать) от технической реализации (как собирать промпты и вызывать API).

---

## Ключевые Концептуальные Принципы

### 1. Stateless Orchestration

DCL Agent является **stateless** компонентом — он не хранит состояние сессии (историю диалога, переменные среды). Управление сессионным контекстом находится **за пределами его ответственности** и реализуется внешним Runtime (например, Session Manager или Conversation Controller).

**Обоснование:** Разделение ответственности между оркестрацией (DCL Agent) и управлением состоянием (Runtime) обеспечивает гибкость архитектуры и упрощает масштабирование.

### 2. Universal Grammar (Агностичность синтаксиса)

Грамматика DCL построена на принципе **универсальности**: синтаксис `Operator Operand ...` агностичен к типам сущностей. Парсер не содержит хардкода имен (PromptModule, Lens и т.д.), а извлекает структуру (Type + Args) в универсальном формате.

**Обоснование:** Это позволяет расширять язык новыми типами сущностей без изменения парсера. Семантика типов определяется Runtime-стратегией, а не синтаксисом.

**Пример:**
```
WRITE PromptModule('NewOp') USING Lens('ArchitecturalStyle')
```
Парсер извлекает: `Entity(type='PromptModule', value='NewOp')`, `Entity(type='Lens', value='ArchitecturalStyle')`.

### 3. Strategy Pattern для сборки контекста

Агент использует паттерн **Стратегия** для сборки `InvocationContext` из разобранной инструкции. Различные стратегии позволяют адаптировать формат контекста под требования конкретных LLM-провайдеров (Gemini, OpenAI и др.) или режимов работы (debug, production).

**Обоснование:** Гибкость в выборе способа формирования контекста критична для интеграции с разными моделями и форматами ввода (текстовые, мультимодальные, структурированные).

### 4. Separation of Model and Data

Система строго разделяет **модель** (структура, правила, операторы — промпт-модули в бандлах) от **данных** (конкретные инструкции пользователя).

**Обоснование:** Изменения в наборе промпт-модулей (добавление новых операторов, линз) не требуют изменения кода агента. Агент остается универсальным интерпретатором.

---

## Разделение ответственности (Separation of Concerns)

Система разделена на 4 ключевых компонента:

1. **Loader (Configurator):** Отвечает за сканирование файловой системы и загрузку prompt modules bundles (Core + Domain bundles).
2. **Parser (Compiler):** Преобразует строковую DCL-инструкцию в промежуточное представление (`Instruction`).
3. **Context Assembler:** Реализует паттерн Стратегия, принимает `Instruction` и возвращает `InvocationContext`.
4. **LLM Adapter:** Адаптер для конкретного LLM-провайдера (Gemini, OpenAI), преобразует `InvocationContext` в формат API.

Каждый компонент может быть изменен или заменен независимо от остальных.

---

## Представление и форматы данных

### Prompt Modules Bundle

Промпт-модули хранятся в виде YAML-файлов, организованных в бандлы (папки):
- **Структура:** `bundle-root/index.yaml` (алиасы) + категории (operations, entities, frameworks, knowledges)
- **Идентификация:** Каждый модуль имеет `id`, `type`, `version` в метаданных
- **Алиасы:** Короткие имена (например, `WRITE`) мапятся на полные версионированные ID (например, `dcl-god-mode/operations/write/4.0`)

### DCL Instruction Syntax

Инструкции описываются на DCL в функциональном стиле:
```
OPERATOR Operand FROM Source(...) USING Modifier(...) OPTIMIZING_FOR Goal(...)
```

### Invocation Context

Результат работы агента — `InvocationContext`, который включает:
- Список фреймов (`ContextFrame`): текстовые блоки, файлы, изображения
- Метаданные (инструменты, параметры генерации)

`InvocationContext` — **платформо-независимый** формат. Адаптер преобразует его в специфичные типы SDK (например, `genai.types.Part` для Gemini).

---

## Минимальные требования к окружению

Для работы с DCL Agent требуется:
- **Python >= 3.12**
- Файловая система для хранения бандлов (MVP)
- API ключ для LLM-провайдера (Gemini в текущей версии)

Для моделирования промпт-модулей достаточно текстового редактора и файлового менеджера.

---

## Бизнес-ценность и сценарии использования

**DCL Agent** обеспечивает:
1. **Декларативное управление контекстом:** Упрощает создание сложных промптов без программирования.
2. **Переиспользуемость:** Операторы, линзы и фреймворки определяются один раз и используются в разных инструкциях.
3. **Версионирование:** Каждый промпт-модуль версионируется, обеспечивая воспроизводимость и контроль изменений.
4. **Масштабируемость:** Поддержка множественных бандлов позволяет комбинировать Core знания (dcl-core) и доменные модули (dcl-god-mode и др.).

**Примеры использования:**
- Генерация кода по спецификации с использованием архитектурных линз
- Анализ документов с применением доменных онтологий
- Создание новых промпт-модулей на основе существующих шаблонов

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2025-12-06 | Создание концепции на основе артефактов SP-001 и SP-002 |
