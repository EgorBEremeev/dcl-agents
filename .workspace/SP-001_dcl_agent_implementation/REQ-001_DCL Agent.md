# Спецификация требований к разработке DCL Agent (Ревью требований)

**Версия:** 6.0 (Final)
**Статус:** Approved
**Дата:** 2025-12-06
**Автор:** AI-Агент (по результатам ревью с Владельцем Продукта)

---

## 1. Введение и Бизнес-контекст

### 1.1 Цель
Разработать класс `DCLAgent`, реализующий исполнение инструкций на языке **Domain Context Language (DCL)**. Этот класс послужит фундаментальным строительным блоком ("оркестратором") в слое **Agentic Runtime**. Его задача — транслировать высокоуровневые бизнес-интенции (описанные на DCL) в серию вызовов LLM API с корректно собранным контекстом.

### 1.2 Роль DCL в архитектуре
DCL Agent является **stateless** компонентом, оперирующим понятиями:
*   **Instruction:** Входная команда (Syntax: `OperatorID Object ...`).
*   **Prompt Modules Bundle:** Набор дизайн-тайм артефактов (Specific Domain + Core), определяющих доступные знания, операторы и линзы.
*   **Invocation Context:** Результат работы агента перед вызовом LLM. Это сложный объект, который может включать не только текстовый системный промпт, но и структурированные части (`genai.types.Part`, мультимедиа, файлы).

Управление **Session Context** (история, stateful-переменные) находится **вне зоны ответственности** данного класса (реализуется внешним Runtime).

---

## 2. Функциональные Требования

### 2.1 Инициализация Агента
Агент должен инициализироваться двумя ключевыми наборами данных:
1.  **DCL Core Bundle:** Базовые определения языка (из `dcl-core`). *Примечание: `dcl-core` задает грамматику и механизмы, а не конкретные операторы.*
2.  **Domain Bundle:** Специфичные для предметной области промпт-модули (например, `dcl-god-mode` или другие). Структура папок в бандле не является жесткой (может не быть `framework` при наличии `operations` и т.д.), агент должен сканировать предоставленный путь.

**Источники:**
*   Локальная файловая система (MVP).
*   *Требование:* Гибкий механизм загрузчиков (Loaders) для будущего расширения.

### 2.2 Компиляция Инструкции (Compiler/Interpreter)
Агент должен принимать строку с DCL-инструкцией и выполнять её разбор согласно грамматике версии **2.3** (Universal DCL).
*   **Universal Grammar:** Синтаксис `Operator Operand ...` должен быть агностичен к типам сущностей. Поддержка функционального стиля `Entity('Args')` для любых идентификаторов (например, `PromptModule('id')`, `Lens('id')`, `MyCustomEntity('id')`).
*   **No Hardcoding:** Парсер не должен содержать хардкода имен сущностей (PromptModule, Lens и т.д.). Он должен извлекать Структуру (Type + Args).
*   **Clauses:** Поддержка стандартных клауз `FROM`, `USING`, `OPTIMIZING_FOR` с аналогичным агностичным разбором ресурсов.
*   **Loose Syntax Handling:** Внутри скобок аргументов синтаксис остается свободным (строка/список), парсер сохраняет его как `value`.

### 2.3 Сборка Контекста (Context Assembly Strategy)
Критически важный функционал. Агент должен поддерживать **стратегию сборки** Invocation Context.
*   **Требование:** Реализация паттерна "Стратегия" (Strategy Pattern) для сборки.
*   **Strategies to Implement (MVP):**
    1.  **Concatenation Strategy:** Линейное объединение содержимого модулей в единую строку.
    2.  **Gemini-Native Context Strategy:** Сборка объекта, структурированного под требования `google.genai`. Результат содержит список `types.Content` или `types.Part`. Это необходимо для корректной передачи мультимодальных данных и сохранения семантики "частей" промпта.
*   **Extensibility:** Возможность добавления новых стратегий в будущем.

### 2.4 Взаимодействие с LLM (LLM Adapter)
*   **Провайдер:** Google Gemini.
*   **Библиотека:** `google-genai` (Official SDK для Python).
*   **Interface Flexibility:** Адаптер должен уметь работать с богатым контекстом (Files, Images, Text Parts), предоставляемым стратегией сборки.

---

## 3. Нефункциональные Требования

1.  **Стек:** Python **>= 3.12**.
2.  **Структура проекта:** Код размещается в директории `c:\git\dcl\src\dcl_agent`.
3.  **Архитектура:** Чистая, модульная (Separation of Concerns).
4.  **Расширяемость:** Возможность добавления новых стратегий сборки и источников модулей.

---

## 4. План перехода к Техническому Решению

В документе Технического Решения будет детально проработано:
1.  **Parsing Implementation:** Реализация парсера для грамматики v2.2.
2.  **Assembly Pipeline:** Проектирование интерфейса `ContextAssembler` -> `InvocationContext` с учетом типов `google.genai`.
